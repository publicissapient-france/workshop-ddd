<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print"/>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Workshop Domain Driven Design Xebia france</title>
    <meta name="Description" CONTENT="Exercise on Domain Driven Design">
</head>

<body>
<div id="container">
<div class="inner">

<header>
    <h1>Workshop Domain Driven Design</h1>

    <h2>By Xebia France</h2>
</header>

<section id="main_content">
<h3>Domain Driven Design Credit</h3>

<p>Le but de l’exercice est d’analyser le code et les règles fonctionnelles afin d’introduire les notions métiers dans le code à l’aide des concepts issues du DDD.</p>

<p>L’application est un back end dans lequel des utilisateurs peuvent valoriser des emprunts.</p>

<p>
    <ul>
        Un utilisateur a un rôle :
        <li> un vendeur (sales) </li>
        <li> un ingénieur financier (pricer)</li>
        <li> un trader</li>
    </ul>
</p>

<p>
    <ul>
        Dans notre domaine, ces utilisateurs possèdent les informations suivantes :
        <li> name : firstname + lastname du user</li>
        <li> email</li>
    </ul>
</p>

<p>
    <ul>
        Un emprunt possède les caractéristiques suivantes :
        <li> il est identifié par le code de référence qui est unique </li>
        <li> il possède des échéances</li>
        <li> il possède des devises (currencies)</li>
    </ul>
</p>

<p>
    <ul>
        Une échéance correspond à des remboursements périodiques:
        <li> une date de remboursement </li>
        <li> un capital restant dû (crd) : c’est le capital total qui reste après paiement de l’échéance</li>
    </ul>
</p>

<p>
Une devise (EUR, USD, CHF, etc) correspond à la monnaie d’un pays. Cela sert notamment à savoir le taux de conversion d’une devise à l’autre. 
Dans les devises, nous avons la notion de funding : ce sont des devises pour lesquelles nous n’avons pas à effectuer de conversion. 
Le projet contient deux fundings : EUR et USD.
La devise de référence est EUR.
</p>

<p>
    <ul>
        L’application est en relation avec deux autres applications pour:
        <li> récupérer les taux de changes (conversions en devises)</li>
        <li> récupérer les utilisateurs</li>
    </ul>
</p>

<p>Enfin un service est présent permettant d'appliquer le taux de conversion sur les échéances si besoin.</p>

<h3>But de l'exercice</h3>

<p>
L'exercice fournit un projet où le domaine est identifié. L'organisation du domaine se base sur l'architecture hexagonale (Port & Adapter).
Le but de l'exercice est de poursuivre le refactoring entamé du domaine.
</p>
<p>
Les entités et values object ont été identifié. Pour renforcer cet aspect, notre entité Credit hérite de la classe Entity et les autres classes héritent de IdValueObject.
</p>
<p>
Afin d'appliquer un des principes de l'architecture hexagonale, la configuration d'Hibernate se fait par des fichiers hbm. Cela nous permet de décorréler la technique de notre domaine.
</p>

<h4>1. CreditId</h4>
<p>
    <p>
        Une entité doit avoir une identité unique. Nous savons qu'un emprunt est identifié par un code de référence. En DDD nous devons typer cet aspect d'identité : c'est le but de la classe CreditId. Cette dernière possède de l'intelligence pour valider ses attributs (id et code de référence). Les méthodes equals et hashcode sont basées sur le code de référence.<br/> 
        Nous devons ajouter cette classe à notre entité Credit :
    </p>
    <ul>
        <li> Modifier le fichier de configuration Credit.hbm et décommenter le code correspondant </li>
        <li> Ajouter l'attribut CreditId dans la classe Credit </li>
        <li> Modifier les méthodes equals et hashcode pour prendre en compte cet attribut</li>
        <li> Ajouter de la validation dans le setter de l'attribut CreditId : ce dernier ne peut pas être null. (n'hésitez pas à utiliser <code>com.google.common.base.Preconditions.checkArgument</code>)</li>
    </ul>
</p>

<h4>2. Echeance & Currency</h4>
<p>
    <p>
    Nous allons encapsuler les échéances et les currencies. En effet en terme objet, ces notions doivent être encapsulées dans une notion de book: un EcheanceBook gère un ensemble d'EcheanceRequest.<br/>
    Aussi en DDD, le point d'entrée pour les opérations sur les objets doit passer par l'entité. L'ajout d'une échéance doit se faire pour la classe Credit et non par la classe EcheanceRequest.
    </p>
    <ul>
        <li> Créer la classe EcheanceRequestBook avec comme attribut la liste des échéances du la classe Credit dans le package approprié</li>
        <li> Créer la classe CurrencyBook avec comme attribut la liste des currencies du la classe Credit dans le package aproprié</li>
        <li> Ajouter les attributs echeanceBook et currencyBook à la classe Credit </li>
        <li> Ajouter la méthode addEcheanceRequest à la classe Credit </li>
        <li> Ajouter la méthode addCurrency à la classe Credit </li>
        <li> Modifier le fichier Credit.hbm (EcheanceBook et CurrencyBook deviennent des component) </li>
        <li> Supprimer les listes echeanceRequests et currencies</li>
        <li> Relancer les tests </li>
    </ul>
    
    <p>Après ce refactoring, les tests peuvent de nouveau passer.</p>
</p>

<h4>3. HibernateCreditRepository</h4>
<p>
    <p>
        La classe CreditRepositoryImpl se trouve dans le domaine. Pour respecter les principes de l'architecture hexagonale, cette classe doit se trouver en dehors du domaine. Nous allons également la renommer afin d'avoir un nom plus parlant
    </p>
    <ul>
        <li> Ajouter un package <code>com.xebia.infrastructure.persistence</code> </li>
        <li> Déplacer la classe CreditRepositoryImpl dans ce package </li>
        <li> Renommer la classe en HibernateCreditRepository </li>
        <li> Modifier également la classe de test correspondante </li>
    </ul>
</p>

<h4>4. CreditDecimal</h4>
<p>
    <p>
        Nous allons modifier la classe EcheanceRequest et son attribut crd. En effet cet attribut est un BigDecimal : pour effectuer des opérations nous devons tester la nullité et gérer les cas d'exception.<br/>
        C'est dans cet optique que la classe CreditDecimal a été créée. Cette dernière encapsule les traitements (gestion des opérations et arrondis). De plus nous avons également défini cette classe comme un attribut Hibernate.
    </p>
    <ul>
        <li> Modifier la classe EcheanceRequest et utiliser CreditDecimal pour le crd </li>
        <li> Modifier le fichier hbm correspondant </li>
        <li> Modifier les tests </li>
    </ul>
</p>

<h4>5. CreditDataService</h4>
<p>
    <p>
        A cette étape, le code ne compile plus car la classe CreditService applique des taux de change. Cependant notre crd est un CreditDecimal et la classe DataService nous retourne des BigDecimal. Etant donnée que ce service est externe, nous allons ajouter une couche anticorruption.<br/>
        Cette couche permet de traduire des notions similaires mais utilisées différemment suivant les domaines.<br/> 
        La classe CreditDataService a déjà été ajoutée. Nous remarquons que cette classe se situe dans le package port.adapter.service pour respecter l'architecture hexagonale.
    </p>
    <ul>
        <li> Modifier la classe CreditDataService qui doit avoir comme attribut la classe DataService. Cette classe aura comme méthode getCrossChange(Date date) et doit retourner un CreditDecimal </li>
        <li> Modifier la classe CreditService </li>
        <li> Modifier les tests </li>
    </ul>
</p>

<h4>6. CreditApplicationService</h4>
<p>
    <p>
        Maintenant que la classe CreditService a été modifié, nous remarquons que son emplacement ne va pas. En effet cette dernière contient une référence vers CreditRepository (le domaine) et vers CreditDataService (extérieur). Toujours pour respecter notre architecture, nous devons déplacer cette classe.
    </p>
    <ul>
        <li> Déplacer la classe CreditService dans le package <code>com.xebia.application</code> </li>
        <li> Renommer CreditService en CreditApplicationService </li>
        <li> Déplacer les tests dans le bon package et voir ci ceux-ci sont toujours au vert</li>
    </ul>
    <p>
        Ce package permet de regrouper les services qui sont en relation avec toute l'application. Le nommage de la classe renforce cet aspect. Nous n'avons pas besoin de chercher pendant des heures pour comprendre ce que la classe fait.
    </p>
</p>

<h4>7. FinancialPerson</h4>
<p>
    <p>
        Notre application communique avec un module de gestion des utilisateurs. Ces derniers possèdent un certain nombre de caractéristiques. Dans notre domaine, seul les attributs name et email nous intéressent. C'est dans cet optique que la classe FinancialPerson a été créée.<br/>
        Nous allons ajouter les trois types d'utilisateurs qui nous intéressent. Le but est de rendre des concepts implicites, explicites :
    </p>
    <ul>
        <li> Dans le package <code>com.xebia.domain.financialPerson</code>, ajouter trois classes final qui héritent de FinancialPerson : Sales, Pricer et Trader </li>
    </ul>
</p>

<h4>8. TranslatingFinancialPersonService</h4>
<p>
    <p>
        Maintenant que nous avons les utilisateurs dans notre domaine, nous devons les initialiser avec les utilisateurs du module. Pour cela nous allons ajouter un élément de traduction du contexte utilisateurs à notre contexte. La classe UserAdapter a été créée dans ce but. A partir d'un User elle permet de construire une FinancialPerson.
        Mais il reste un peu de travail :
    </p>
    <ul>
        <li>Décommenter les méthodes à implémenter dans l'interface FinancialPersonService</li>
        <li> Dans le package <code>com.xebia.port.adpater.service</code>, créer la classe TranslatingFinancialPersonService qui doit implémenter l'interface FinancialPersonService</li>
        <li> Ajouter l'attribut UserAdapter </li>
        <li> Implémenter les méthodes en utilisant la méthode toFinancialPerson du UserAdapter </li>
        <li> Modifier les tests de la classe UserAdapter </li>
    </ul>
</p>

<h4>9. EmailAddress</h4>
<p>
    <p>
        Toujours dans le but de rendre des concepts implicites, explicites, nous allons ajouter un value object EmailAddress. En effet cette classe se chargera de valider le format du mail. Nous appliquons içi le principe SRP (Single Responsibility Principle)
    </p>
    <ul>
        <li> Dans le package <code>com.xebia.domain.financialPerson</code>, créer la classe EmailAddress en final </li>
        <li> Créer un constructeur public avec comme paramètre String mail. Ce constructeur fait appel à la méthode <code>private void setMail (String mail)</code> </li>
        <li> L'usage du TDD est conseillé (vous pouvez aussi directement aller modifier le test existant)</li>
        <li> Ce setter doit attribuer la chaîne de caractère mais aussi la valider. Il faut vérifier la non nullité et le format du mail. Voici la regex pour vous aider <code>
        "\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*"</code> La encore allez voir du côté de <code>com.google.common.base</code> ;)</li>
        <li> Modifier le type de l'attribut email dans la classe FinancialPerson </li>
        <li> Modifier la classe UserAdapter </li>
        <li> Relancer une dernière fois les tests pour vérifier que votre Refactoring n'a pas modifié le comportement métier !</li>
    </ul>
</p>

<h4>10. Bravo !</h4>
<p>Vous avez maintenant du code conçu autour du modèle métier en s'inspirant de l'architecture hexagonale.
    <br/>Si vous souhaitez approfondir:
    <ul>
        <li><a href="http://blog.infosaurus.fr/public/docs/DDDViteFaitPartie1.pdf">http://blog.infosaurus.fr/public/docs/DDDViteFaitPartie1.pdf</a></li>
        <li><a href="http://en.wikipedia.org/wiki/Domain-driven_design">http://en.wikipedia.org/wiki/Domain-driven_design</a></li>
        <li><a href="http://alistair.cockburn.us/Hexagonal+architecture">http://alistair.cockburn.us/Hexagonal+architecture</a></li>
        <li><a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html</a></li>
    </ul>
</p>

<footer>

    <h3>Authors and Contributors</h3>

    <p>
        Nicolas Jozwiak (<a href="https://github.com/njozwiak" class="user-mention">@njozwiak</a>),<br/>
        Gérôme Egron (<a href="https://github.com/gegron" class="user-mention">@gegron</a>),<br/>
        Jean-Eudes Couignoux (<a href="https://github.com/jeudes" class="user-mention">@jeudes</a>),<br/>
        Yannick Grenzinger (<a href="https://github.com/ygrenzinger" class="user-mention">@ygrenzinger</a>),<br/> 
    </p>

    Workshop-ddd is maintained by <a href="https://github.com/xebia-france">xebia-france</a><br>

    <p>Le contenu de ce workshop est sous <a
            href="http://creativecommons.org/licenses/by-nc-nd/2.0/fr/">contrat Creative Commons</a>.<br> <br> <a
            href="http://creativecommons.org/licenses/by-nc-nd/2.0/fr/"><img
            src="http://blog.xebia.fr/wp-content/uploads/2012/01/by-nc-nd.png"></a></p>
</footer>

</div>
</div>
</body>
</html>
